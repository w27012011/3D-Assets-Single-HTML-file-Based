<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Premium 3D Assets Library</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #050505;
            color: #fff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow-x: hidden;
        }
        
        .section {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .copy-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            min-width: 320px;
            max-width: 400px;
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .copy-panel.active {
            transform: translateX(0);
        }
        
        .copy-panel h3 {
            font-size: 14px;
            font-weight: 500;
            color: #888;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .code-preview {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 11px;
            color: #a0a0a0;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .copy-btn {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }
        
        .copy-btn.copied {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        
        .section-indicator {
            position: fixed;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .indicator-dot.active {
            background: #667eea;
            box-shadow: 0 0 20px #667eea;
            transform: scale(1.5);
        }
        
        .asset-label {
            position: absolute;
            bottom: 40px;
            left: 40px;
            z-index: 100;
        }
        
        .asset-label h2 {
            font-size: 42px;
            font-weight: 300;
            letter-spacing: -1px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fff 0%, #888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .asset-label p {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .grab-cursor {
            cursor: grab;
        }
        
        .grab-cursor:active {
            cursor: grabbing;
        }
        
        .toast {
            position: fixed;
            bottom: 40px;
            right: 40px;
            background: rgba(17, 153, 142, 0.95);
            color: white;
            padding: 16px 28px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 2000;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .click-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .section:hover .click-hint {
            opacity: 1;
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- Section 1: Geometric + Wireframe -->
    <div class="section" id="section1" data-scene="geometric-wireframe">
        <div class="canvas-container" id="canvas1"></div>
        <div class="asset-label">
            <h2>Geometric Wireframe</h2>
            <p>Solid Polyhedrons + Floating Cages</p>
        </div>
        <div class="click-hint">Click to copy code</div>
    </div>
    
    <!-- Section 2: Organic + Geometric -->
    <div class="section" id="section2" data-scene="organic-geometric">
        <div class="canvas-container" id="canvas2"></div>
        <div class="asset-label">
            <h2>Organic Fusion</h2>
            <p>Fluid Blobs + Precise Forms</p>
        </div>
        <div class="click-hint">Click to copy code</div>
    </div>
    
    <!-- Section 3: Architecture + Rings -->
    <div class="section" id="section3" data-scene="architecture-rings">
        <div class="canvas-container" id="canvas3"></div>
        <div class="asset-label">
            <h2>Neo Architecture</h2>
            <p>Floating City + Orbital Rings</p>
        </div>
        <div class="click-hint">Click to copy code</div>
    </div>
    
    <!-- Section 4: Scientific + Abstract -->
    <div class="section" id="section4" data-scene="scientific-abstract">
        <div class="canvas-container" id="canvas4"></div>
        <div class="asset-label">
            <h2>Scientific Abstract</h2>
            <p>DNA Helix + Electron Orbits</p>
        </div>
        <div class="click-hint">Click to copy code</div>
    </div>
    
    <!-- Section 5: Premium Morphing -->
    <div class="section" id="section5" data-scene="morphing-shapes">
        <div class="canvas-container" id="canvas5"></div>
        <div class="asset-label">
            <h2>Morphing Forms</h2>
            <p>Shape-Shifting Geometry</p>
        </div>
        <div class="click-hint">Click to copy code</div>
    </div>
    
    <!-- Section 6: Particle Field -->
    <div class="section" id="section6" data-scene="particle-field">
        <div class="canvas-container" id="canvas6"></div>
        <div class="asset-label">
            <h2>Particle Cosmos</h2>
            <p>Interactive Particle Network</p>
        </div>
        <div class="click-hint">Click to copy code</div>
    </div>

    <!-- Copy Panel -->
    <div class="copy-panel" id="copyPanel">
        <h3>Asset Code</h3>
        <div class="code-preview" id="codePreview">// Click on any scene to view code</div>
        <button class="copy-btn" id="copyBtn" data-clipboard-target="#codePreview">Copy to Clipboard</button>
    </div>
    
    <!-- Section Indicators -->
    <div class="section-indicator">
        <div class="indicator-dot active" data-section="0"></div>
        <div class="indicator-dot" data-section="1"></div>
        <div class="indicator-dot" data-section="2"></div>
        <div class="indicator-dot" data-section="3"></div>
        <div class="indicator-dot" data-section="4"></div>
        <div class="indicator-dot" data-section="5"></div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast">Code copied to clipboard!</div>

    <script>
        // ============================================
        // PREMIUM 3D ASSETS LIBRARY
        // ============================================
        
        const scenes = {};
        const sceneCodes = {};
        let currentScene = null;
        let copyPanelOpen = false;
        
        // Utility: Create renderer with premium settings
        function createPremiumRenderer(container) {
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            renderer.domElement.classList.add('grab-cursor');
            return renderer;
        }
        
        // Utility: Create premium lighting
        function createPremiumLighting(scene) {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 7);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            const rimLight = new THREE.SpotLight(0x667eea, 2);
            rimLight.position.set(-5, 5, -5);
            rimLight.lookAt(0, 0, 0);
            scene.add(rimLight);
            
            const fillLight = new THREE.PointLight(0x764ba2, 0.8);
            fillLight.position.set(5, -5, 5);
            scene.add(fillLight);
            
            return { mainLight, rimLight, fillLight };
        }
        
        // ============================================
        // SCENE 1: GEOMETRIC + WIREFRAME
        // ============================================
        function initGeometricWireframe() {
            const container = document.getElementById('canvas1');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);
            
            const renderer = createPremiumRenderer(container);
            const lights = createPremiumLighting(scene);
            
            const group = new THREE.Group();
            scene.add(group);
            
            // Metallic solid cube
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const cubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x888888,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1,
                clearcoatRoughness: 0.1,
                envMapIntensity: 1.5
            });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.castShadow = true;
            cube.receiveShadow = true;
            group.add(cube);
            
            // Wireframe sphere cage
            const wireframeGeometry = new THREE.IcosahedronGeometry(3.5, 2);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x667eea,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const wireframeSphere = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            group.add(wireframeSphere);
            
            // Inner wireframe octahedron
            const innerWireGeometry = new THREE.OctahedronGeometry(2.8, 1);
            const innerWireMaterial = new THREE.MeshBasicMaterial({
                color: 0x764ba2,
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            const innerWire = new THREE.Mesh(innerWireGeometry, innerWireMaterial);
            group.add(innerWire);
            
            // Floating geometric particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 100;
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 15;
                positions[i + 1] = (Math.random() - 0.5) * 15;
                positions[i + 2] = (Math.random() - 0.5) * 15;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                color: 0x667eea,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                cube.rotation.x += 0.005;
                cube.rotation.y += 0.007;
                
                wireframeSphere.rotation.x -= 0.003;
                wireframeSphere.rotation.y += 0.004;
                
                innerWire.rotation.x += 0.006;
                innerWire.rotation.z -= 0.004;
                
                // Pulse effect
                const scale = 1 + Math.sin(time * 2) * 0.05;
                wireframeSphere.scale.set(scale, scale, scale);
                
                particles.rotation.y += 0.001;
                
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            // Store scene data
            scenes.geometricWireframe = { renderer, camera, scene, controls };
            
            // Code for copying
            sceneCodes.geometricWireframe = `// Geometric Wireframe 3D Component
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
camera.position.set(0, 0, 8);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(width, height);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.shadowMap.enabled = true;

// Metallic Cube
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshPhysicalMaterial({
    color: 0x888888,
    metalness: 0.9,
    roughness: 0.1,
    clearcoat: 1
  })
);

// Wireframe Cage
const wireframe = new THREE.Mesh(
  new THREE.IcosahedronGeometry(3.5, 2),
  new THREE.MeshBasicMaterial({
    color: 0x667eea,
    wireframe: true,
    transparent: true,
    opacity: 0.3
  })
);

// Animation
cube.rotation.x += 0.005;
cube.rotation.y += 0.007;
wireframe.rotation.x -= 0.003;`;
            
            return { renderer, camera };
        }
        
        // ============================================
        // SCENE 2: ORGANIC + GEOMETRIC
        // ============================================
        function initOrganicGeometric() {
            const container = document.getElementById('canvas2');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.015);
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);
            
            const renderer = createPremiumRenderer(container);
            createPremiumLighting(scene);
            
            const group = new THREE.Group();
            scene.add(group);
            
            // Create organic blob using modified sphere
            const blobGeometry = new THREE.SphereGeometry(2, 128, 128);
            const blobMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xff6b6b,
                metalness: 0.3,
                roughness: 0.2,
                transmission: 0.6,
                thickness: 2,
                clearcoat: 1,
                clearcoatRoughness: 0.1
            });
            const blob = new THREE.Mesh(blobGeometry, blobMaterial);
            blob.position.y = 1;
            group.add(blob);
            
            // Store original positions for morphing
            const originalPositions = blobGeometry.attributes.position.array.slice();
            
            // Precise geometric cubes stack
            const cubeGroup = new THREE.Group();
            const cubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x4ecdc4,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1
            });
            
            for (let i = 0; i < 5; i++) {
                const size = 1.2 - i * 0.15;
                const cube = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    cubeMaterial
                );
                cube.position.y = -2.5 + i * 0.8;
                cube.rotation.y = i * 0.3;
                cube.castShadow = true;
                cubeGroup.add(cube);
            }
            group.add(cubeGroup);
            
            // Floating geometric shards
            const shardGeometry = new THREE.TetrahedronGeometry(0.3);
            const shardMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffe66d,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xffe66d,
                emissiveIntensity: 0.2
            });
            
            const shards = [];
            for (let i = 0; i < 20; i++) {
                const shard = new THREE.Mesh(shardGeometry, shardMaterial);
                shard.position.set(
                    (Math.random() - 0.5) * 12,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                shard.userData = {
                    speed: Math.random() * 0.02 + 0.01,
                    axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize()
                };
                group.add(shard);
                shards.push(shard);
            }
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                // Morph blob
                const positions = blobGeometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = originalPositions[i];
                    const y = originalPositions[i + 1];
                    const z = originalPositions[i + 2];
                    
                    const noise = Math.sin(x * 2 + time) * Math.cos(y * 2 + time) * Math.sin(z * 2 + time);
                    const displacement = 1 + noise * 0.15;
                    
                    positions[i] = x * displacement;
                    positions[i + 1] = y * displacement;
                    positions[i + 2] = z * displacement;
                }
                blobGeometry.attributes.position.needsUpdate = true;
                blobGeometry.computeVertexNormals();
                
                // Animate cubes
                cubeGroup.children.forEach((cube, i) => {
                    cube.rotation.y += 0.01 * (i + 1) * 0.3;
                    cube.position.y = -2.5 + i * 0.8 + Math.sin(time * 2 + i) * 0.1;
                });
                
                // Animate shards
                shards.forEach(shard => {
                    shard.rotateOnAxis(shard.userData.axis, shard.userData.speed);
                    shard.position.y += Math.sin(time + shard.position.x) * 0.005;
                });
                
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            scenes.organicGeometric = { renderer, camera, scene, controls };
            
            sceneCodes.organicGeometric = `// Organic + Geometric 3D Component
const blobGeometry = new THREE.SphereGeometry(2, 128, 128);
const blob = new THREE.Mesh(
  blobGeometry,
  new THREE.MeshPhysicalMaterial({
    color: 0xff6b6b,
    transmission: 0.6,
    thickness: 2,
    clearcoat: 1
  })
);

// Morph animation
const positions = blobGeometry.attributes.position.array;
const original = positions.slice();
const time = performance.now() * 0.001;

for (let i = 0; i < positions.length; i += 3) {
  const noise = Math.sin(original[i] * 2 + time) * 
                Math.cos(original[i+1] * 2 + time) * 
                Math.sin(original[i+2] * 2 + time);
  const displacement = 1 + noise * 0.15;
  positions[i] *= displacement;
  positions[i+1] *= displacement;
  positions[i+2] *= displacement;
}
blobGeometry.attributes.position.needsUpdate = true;`;
            
            return { renderer, camera };
        }
        
        // ============================================
        // SCENE 3: ARCHITECTURE + RINGS
        // ============================================
        function initArchitectureRings() {
            const container = document.getElementById('canvas3');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.012);
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 4, 8);
            
            const renderer = createPremiumRenderer(container);
            createPremiumLighting(scene);
            
            const group = new THREE.Group();
            scene.add(group);
            
            // Mini cityscape
            const cityGroup = new THREE.Group();
            const buildingMaterials = [
                new THREE.MeshPhysicalMaterial({ color: 0x2d3436, metalness: 0.8, roughness: 0.3 }),
                new THREE.MeshPhysicalMaterial({ color: 0x636e72, metalness: 0.7, roughness: 0.4 }),
                new THREE.MeshPhysicalMaterial({ color: 0xb2bec3, metalness: 0.6, roughness: 0.5 })
            ];
            
            // Create floating buildings
            for (let i = 0; i < 15; i++) {
                const width = 0.3 + Math.random() * 0.5;
                const height = 1 + Math.random() * 2.5;
                const depth = 0.3 + Math.random() * 0.5;
                
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)]
                );
                
                const angle = (i / 15) * Math.PI * 2;
                const radius = 2 + Math.random() * 1.5;
                building.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 2,
                    Math.sin(angle) * radius
                );
                building.rotation.y = Math.random() * Math.PI;
                building.castShadow = true;
                cityGroup.add(building);
                
                // Add windows (emissive planes)
                const windowCount = Math.floor(height * 3);
                for (let w = 0; w < windowCount; w++) {
                    if (Math.random() > 0.6) {
                        const windowPlane = new THREE.Mesh(
                            new THREE.PlaneGeometry(0.08, 0.08),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xffeaa7,
                                transparent: true,
                                opacity: 0.8
                            })
                        );
                        windowPlane.position.set(
                            building.position.x + (Math.random() - 0.5) * width * 0.8,
                            building.position.y - height/2 + (w / windowCount) * height,
                            building.position.z + depth/2 + 0.01
                        );
                        cityGroup.add(windowPlane);
                    }
                }
            }
            group.add(cityGroup);
            
            // Orbital rings
            const ringGroup = new THREE.Group();
            const ringConfigs = [
                { radius: 5, tube: 0.05, color: 0x74b9ff, speed: 0.002 },
                { radius: 6, tube: 0.03, color: 0xa29bfe, speed: -0.003 },
                { radius: 7, tube: 0.04, color: 0xfd79a8, speed: 0.0015 }
            ];
            
            ringConfigs.forEach((config, i) => {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(config.radius, config.tube, 16, 100),
                    new THREE.MeshPhysicalMaterial({
                        color: config.color,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: config.color,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                ring.rotation.x = Math.PI / 2 + (i * 0.3);
                ring.rotation.y = i * 0.5;
                ring.userData = { speed: config.speed };
                ringGroup.add(ring);
            });
            group.add(ringGroup);
            
            // Central prism
            const prism = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.8, 4, 6),
                new THREE.MeshPhysicalMaterial({
                    color: 0x00cec9,
                    metalness: 0.9,
                    roughness: 0.1,
                    transmission: 0.3,
                    clearcoat: 1
                })
            );
            group.add(prism);
            
            // Floating platforms
            for (let i = 0; i < 3; i++) {
                const platform = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.5 - i * 0.3, 1.5 - i * 0.3, 0.1, 8),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x636e72,
                        metalness: 0.8,
                        roughness: 0.3,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                platform.position.y = -3 + i * 3;
                platform.rotation.y = i * Math.PI / 4;
                group.add(platform);
            }
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.2;
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                // Rotate city
                cityGroup.rotation.y += 0.002;
                
                // Animate rings
                ringGroup.children.forEach(ring => {
                    ring.rotation.z += ring.userData.speed;
                });
                ringGroup.rotation.y += 0.001;
                
                // Pulse prism
                prism.rotation.y += 0.01;
                const scale = 1 + Math.sin(time * 3) * 0.02;
                prism.scale.set(scale, 1, scale);
                
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            scenes.architectureRings = { renderer, camera, scene, controls };
            
            sceneCodes.architectureRings = `// Architecture + Rings 3D Component
const cityGroup = new THREE.Group();

// Generate buildings
for (let i = 0; i < 15; i++) {
  const building = new THREE.Mesh(
    new THREE.BoxGeometry(
      0.3 + Math.random() * 0.5,
      1 + Math.random() * 2.5,
      0.3 + Math.random() * 0.5
    ),
    new THREE.MeshPhysicalMaterial({
      color: 0x2d3436,
      metalness: 0.8,
      roughness: 0.3
    })
  );
  const angle = (i / 15) * Math.PI * 2;
  const radius = 2 + Math.random() * 1.5;
  building.position.set(
    Math.cos(angle) * radius,
    (Math.random() - 0.5) * 2,
    Math.sin(angle) * radius
  );
  cityGroup.add(building);
}

// Orbital rings
const ring = new THREE.Mesh(
  new THREE.TorusGeometry(5, 0.05, 16, 100),
  new THREE.MeshPhysicalMaterial({
    color: 0x74b9ff,
    metalness: 0.9,
    emissive: 0x74b9ff,
    emissiveIntensity: 0.3
  })
);
ring.rotation.x = Math.PI / 2;

// Animation
cityGroup.rotation.y += 0.002;
ring.rotation.z += 0.002;`;
            
            return { renderer, camera };
        }
        
        // ============================================
        // SCENE 4: SCIENTIFIC + ABSTRACT
        // ============================================
        function initScientificAbstract() {
            const container = document.getElementById('canvas4');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.018);
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 12);
            
            const renderer = createPremiumRenderer(container);
            createPremiumLighting(scene);
            
            const group = new THREE.Group();
            scene.add(group);
            
            // DNA Helix
            const helixGroup = new THREE.Group();
            const strandCount = 40;
            const helixRadius = 1.5;
            const helixHeight = 8;
            
            const baseMaterial1 = new THREE.MeshPhysicalMaterial({
                color: 0x00b894,
                metalness: 0.7,
                roughness: 0.2,
                clearcoat: 1
            });
            const baseMaterial2 = new THREE.MeshPhysicalMaterial({
                color: 0xe17055,
                metalness: 0.7,
                roughness: 0.2,
                clearcoat: 1
            });
            
            for (let i = 0; i < strandCount; i++) {
                const t = i / strandCount;
                const angle = t * Math.PI * 8;
                const y = (t - 0.5) * helixHeight;
                
                // Strand 1
                const sphere1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 16, 16),
                    baseMaterial1
                );
                sphere1.position.set(
                    Math.cos(angle) * helixRadius,
                    y,
                    Math.sin(angle) * helixRadius
                );
                helixGroup.add(sphere1);
                
                // Strand 2
                const sphere2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 16, 16),
                    baseMaterial2
                );
                sphere2.position.set(
                    Math.cos(angle + Math.PI) * helixRadius,
                    y,
                    Math.sin(angle + Math.PI) * helixRadius
                );
                helixGroup.add(sphere2);
                
                // Connector
                const connector = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, helixRadius * 2, 8),
                    new THREE.MeshPhysicalMaterial({
                        color: 0x74b9ff,
                        metalness: 0.5,
                        roughness: 0.3,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                connector.position.set(0, y, 0);
                connector.rotation.z = Math.PI / 2;
                connector.rotation.y = angle;
                helixGroup.add(connector);
            }
            group.add(helixGroup);
            
            // Electron orbits
            const orbitGroup = new THREE.Group();
            const electronCount = 8;
            
            for (let i = 0; i < 3; i++) {
                const orbitRadius = 4 + i * 1.5;
                const orbitGeometry = new THREE.RingGeometry(orbitRadius - 0.02, orbitRadius + 0.02, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: 0xa29bfe,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2 + i * 0.5;
                orbit.rotation.y = i * 0.8;
                orbitGroup.add(orbit);
                
                // Electrons on this orbit
                for (let j = 0; j < electronCount; j++) {
                    const electron = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 16, 16),
                        new THREE.MeshPhysicalMaterial({
                            color: 0xfdcb6e,
                            metalness: 0.9,
                            roughness: 0.1,
                            emissive: 0xfdcb6e,
                            emissiveIntensity: 0.5
                        })
                    );
                    electron.userData = {
                        orbitRadius: orbitRadius,
                        angle: (j / electronCount) * Math.PI * 2,
                        speed: 0.01 + Math.random() * 0.01,
                        orbitIndex: i
                    };
                    orbitGroup.add(electron);
                }
            }
            group.add(orbitGroup);
            
            // Geometric grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x636e72, 0x2d3436);
            gridHelper.position.y = -5;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.3;
            group.add(gridHelper);
            
            // Floating geometric shapes
            const shapes = [];
            const shapeGeometries = [
                new THREE.OctahedronGeometry(0.4),
                new THREE.TetrahedronGeometry(0.5),
                new THREE.IcosahedronGeometry(0.3)
            ];
            const shapeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x6c5ce7,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            
            for (let i = 0; i < 12; i++) {
                const shape = new THREE.Mesh(
                    shapeGeometries[i % 3],
                    shapeMaterial
                );
                shape.position.set(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                shape.userData = {
                    rotationSpeed: Math.random() * 0.03,
                    floatSpeed: Math.random() * 0.01
                };
                group.add(shape);
                shapes.push(shape);
            }
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.4;
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                // Rotate DNA
                helixGroup.rotation.y += 0.005;
                
                // Animate electrons
                orbitGroup.children.forEach(child => {
                    if (child.userData.orbitRadius) {
                        child.userData.angle += child.userData.speed;
                        const i = child.userData.orbitIndex;
                        const baseAngle = child.userData.angle;
                        child.position.x = Math.cos(baseAngle) * child.userData.orbitRadius;
                        child.position.z = Math.sin(baseAngle) * child.userData.orbitRadius;
                        child.position.y = Math.sin(baseAngle * 2 + i) * 0.5;
                    }
                });
                
                // Animate shapes
                shapes.forEach(shape => {
                    shape.rotation.x += shape.userData.rotationSpeed;
                    shape.rotation.y += shape.userData.rotationSpeed;
                    shape.position.y += Math.sin(time + shape.position.x) * shape.userData.floatSpeed;
                });
                
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            scenes.scientificAbstract = { renderer, camera, scene, controls };
            
            sceneCodes.scientificAbstract = `// Scientific Abstract 3D Component
const helixGroup = new THREE.Group();
const strandCount = 40;
const helixRadius = 1.5;

// Create DNA strands
for (let i = 0; i < strandCount; i++) {
  const t = i / strandCount;
  const angle = t * Math.PI * 8;
  const y = (t - 0.5) * 8;
  
  const sphere1 = new THREE.Mesh(
    new THREE.SphereGeometry(0.25, 16, 16),
    new THREE.MeshPhysicalMaterial({ color: 0x00b894 })
  );
  sphere1.position.set(
    Math.cos(angle) * helixRadius,
    y,
    Math.sin(angle) * helixRadius
  );
  
  const sphere2 = new THREE.Mesh(
    new THREE.SphereGeometry(0.25, 16, 16),
    new THREE.MeshPhysicalMaterial({ color: 0xe17055 })
  );
  sphere2.position.set(
    Math.cos(angle + Math.PI) * helixRadius,
    y,
    Math.sin(angle + Math.PI) * helixRadius
  );
  
  helixGroup.add(sphere1);
  helixGroup.add(sphere2);
}

// Animation
helixGroup.rotation.y += 0.005;`;
            
            return { renderer, camera };
        }
        
        // ============================================
        // SCENE 5: MORPHING SHAPES
        // ============================================
        function initMorphingShapes() {
            const container = document.getElementById('canvas5');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 7);
            
            const renderer = createPremiumRenderer(container);
            createPremiumLighting(scene);
            
            const group = new THREE.Group();
            scene.add(group);
            
            // Create morphing geometry
            const geometry = new THREE.IcosahedronGeometry(2, 4);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0x667eea,
                metalness: 0.6,
                roughness: 0.2,
                clearcoat: 1,
                clearcoatRoughness: 0.1,
                flatShading: false
            });
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            
            // Store original positions
            const originalPositions = geometry.attributes.position.array.slice();
            const count = geometry.attributes.position.count;
            
            // Add wireframe overlay
            const wireframe = new THREE.Mesh(
                geometry,
                new THREE.MeshBasicMaterial({
                    color: 0xff6b6b,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.15
                })
            );
            group.add(wireframe);
            
            // Floating particles around
            const particleCount = 200;
            const particlesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3 + Math.random() * 4;
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                velocities.push({
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                });
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                color: 0xa29bfe,
                size: 0.06,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            group.add(particles);
            
            // Outer glow ring
            const glowRing = new THREE.Mesh(
                new THREE.TorusGeometry(4.5, 0.02, 16, 100),
                new THREE.MeshBasicMaterial({
                    color: 0x667eea,
                    transparent: true,
                    opacity: 0.4
                })
            );
            glowRing.rotation.x = Math.PI / 2;
            group.add(glowRing);
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                // Morph the mesh
                const positions = geometry.attributes.position.array;
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const x = originalPositions[i3];
                    const y = originalPositions[i3 + 1];
                    const z = originalPositions[i3 + 2];
                    
                    // Complex morphing using multiple sine waves
                    const morph1 = Math.sin(x * 2 + time * 2) * Math.cos(y * 2 + time);
                    const morph2 = Math.cos(z * 2 + time * 1.5) * Math.sin(x * 2);
                    const morph3 = Math.sin(time * 0.5) * 0.3;
                    
                    const displacement = 1 + (morph1 + morph2) * 0.2 + morph3;
                    
                    positions[i3] = x * displacement;
                    positions[i3 + 1] = y * displacement;
                    positions[i3 + 2] = z * displacement;
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                
                // Update wireframe
                wireframe.geometry.attributes.position.array.set(positions);
                wireframe.geometry.attributes.position.needsUpdate = true;
                
                // Animate particles
                const particlePositions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    particlePositions[i3] += velocities[i].x;
                    particlePositions[i3 + 1] += velocities[i].y;
                    particlePositions[i3 + 2] += velocities[i].z;
                    
                    // Boundary check
                    const dist = Math.sqrt(
                        particlePositions[i3] ** 2 + 
                        particlePositions[i3 + 1] ** 2 + 
                        particlePositions[i3 + 2] ** 2
                    );
                    
                    if (dist > 8) {
                        particlePositions[i3] *= 0.5;
                        particlePositions[i3 + 1] *= 0.5;
                        particlePositions[i3 + 2] *= 0.5;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.rotation.y += 0.002;
                
                // Animate glow ring
                glowRing.rotation.x = Math.PI / 2 + Math.sin(time) * 0.3;
                glowRing.rotation.y += 0.005;
                
                // Color shift
                const hue = (time * 0.05) % 1;
                material.color.setHSL(0.6 + hue * 0.2, 0.8, 0.6);
                
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            scenes.morphingShapes = { renderer, camera, scene, controls };
            
            sceneCodes.morphingShapes = `// Morphing Shapes 3D Component
const geometry = new THREE.IcosahedronGeometry(2, 4);
const material = new THREE.MeshPhysicalMaterial({
  color: 0x667eea,
  metalness: 0.6,
  roughness: 0.2,
  clearcoat: 1
});
const mesh = new THREE.Mesh(geometry, material);

const originalPositions = geometry.attributes.position.array.slice();
const count = geometry.attributes.position.count;
const time = performance.now() * 0.001;

// Morph animation
for (let i = 0; i < count; i++) {
  const i3 = i * 3;
  const x = originalPositions[i3];
  const y = originalPositions[i3 + 1];
  const z = originalPositions[i3 + 2];
  
  const morph1 = Math.sin(x * 2 + time * 2) * Math.cos(y * 2 + time);
  const morph2 = Math.cos(z * 2 + time * 1.5) * Math.sin(x * 2);
  
  const displacement = 1 + (morph1 + morph2) * 0.2;
  
  geometry.attributes.position.array[i3] = x * displacement;
  geometry.attributes.position.array[i3+1] = y * displacement;
  geometry.attributes.position.array[i3+2] = z * displacement;
}

geometry.attributes.position.needsUpdate = true;
geometry.computeVertexNormals();`;
            
            return { renderer, camera };
        }
        
        // ============================================
        // SCENE 6: PARTICLE FIELD
        // ============================================
        function initParticleField() {
            const container = document.getElementById('canvas6');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.008);
            
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            const renderer = createPremiumRenderer(container);
            createPremiumLighting(scene);
            
            const group = new THREE.Group();
            scene.add(group);
            
            // Create particle field
            const particleCount = 800;
            const particlesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const originalPositions = [];
            
            const colorPalette = [
                new THREE.Color(0x667eea),
                new THREE.Color(0x764ba2),
                new THREE.Color(0xf093fb),
                new THREE.Color(0x4facfe)
            ];
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Create spherical distribution
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 5 + Math.random() * 10;
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                originalPositions.push({
                    x: positions[i3],
                    y: positions[i3 + 1],
                    z: positions[i3 + 2],
                    theta: theta,
                    phi: phi,
                    radius: radius,
                    speed: 0.002 + Math.random() * 0.003
                });
                
                // Color
                const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                sizes[i] = 0.1 + Math.random() * 0.2;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Custom shader material for particles
            const particlesMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec3 pos = position;
                        
                        // Add wave motion
                        pos.x += sin(time * 0.5 + position.y * 0.5) * 0.5;
                        pos.y += cos(time * 0.3 + position.x * 0.5) * 0.5;
                        pos.z += sin(time * 0.4 + position.z * 0.3) * 0.3;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        // Create circular particle
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;
                        
                        // Soft edge
                        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                        
                        // Glow effect
                        float glow = 1.0 - dist * 2.0;
                        glow = pow(glow, 2.0);
                        
                        gl_FragColor = vec4(vColor + glow * 0.3, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            group.add(particles);
            
            // Connection lines
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.15
            });
            
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = new Float32Array(particleCount * 6); // 2 points per line, 3 coords each
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            group.add(lines);
            
            // Central attractor
            const attractor = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5
                })
            );
            group.add(attractor);
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.15;
            
            // Mouse interaction
            const mouse = new THREE.Vector2();
            const targetRotation = new THREE.Vector2();
            
            document.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                particlesMaterial.uniforms.time.value = time;
                
                // Rotate entire field
                group.rotation.y += 0.001;
                
                // Pulse attractor
                const attractorScale = 1 + Math.sin(time * 3) * 0.2;
                attractor.scale.set(attractorScale, attractorScale, attractorScale);
                
                // Update connections
                const positions = particles.geometry.attributes.position.array;
                const linePos = lines.geometry.attributes.position.array;
                let lineIndex = 0;
                const maxConnections = 3;
                const connectionDistance = 3;
                
                for (let i = 0; i < Math.min(particleCount, 100); i++) {
                    let connections = 0;
                    const i3 = i * 3;
                    
                    for (let j = i + 1; j < Math.min(particleCount, 100); j++) {
                        if (connections >= maxConnections) break;
                        
                        const j3 = j * 3;
                        const dx = positions[i3] - positions[j3];
                        const dy = positions[i3 + 1] - positions[j3 + 1];
                        const dz = positions[i3 + 2] - positions[j3 + 2];
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (dist < connectionDistance) {
                            linePos[lineIndex++] = positions[i3];
                            linePos[lineIndex++] = positions[i3 + 1];
                            linePos[lineIndex++] = positions[i3 + 2];
                            linePos[lineIndex++] = positions[j3];
                            linePos[lineIndex++] = positions[j3 + 1];
                            linePos[lineIndex++] = positions[j3 + 2];
                            connections++;
                        }
                    }
                }
                
                // Clear remaining line positions
                for (let i = lineIndex; i < linePositions.length; i++) {
                    linePos[i] = 0;
                }
                
                lines.geometry.attributes.position.needsUpdate = true;
                
                // Mouse influence on rotation
                targetRotation.x = mouse.y * 0.1;
                targetRotation.y = mouse.x * 0.1;
                group.rotation.x += (targetRotation.x - group.rotation.x) * 0.05;
                group.rotation.z += (targetRotation.y - group.rotation.z) * 0.05;
                
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            scenes.particleField = { renderer, camera, scene, controls };
            
            sceneCodes.particleField = `// Particle Field 3D Component
const particleCount = 800;
const particlesGeometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const colors = new Float32Array(particleCount * 3);

// Initialize particles
for (let i = 0; i < particleCount; i++) {
  const i3 = i * 3;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  const radius = 5 + Math.random() * 10;
  
  positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
  positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
  positions[i3 + 2] = radius * Math.cos(phi);
}

particlesGeometry.setAttribute('position', 
  new THREE.BufferAttribute(positions, 3));

const particlesMaterial = new THREE.PointsMaterial({
  color: 0x667eea,
  size: 0.15,
  transparent: true,
  opacity: 0.8,
  blending: THREE.AdditiveBlending
});

const particles = new THREE.Points(particlesGeometry, particlesMaterial);

// Animation
particles.rotation.y += 0.001;`;
            
            return { renderer, camera };
        }
        
        // ============================================
        // INITIALIZE ALL SCENES
        // ============================================
        function initAllScenes() {
            initGeometricWireframe();
            initOrganicGeometric();
            initArchitectureRings();
            initScientificAbstract();
            initMorphingShapes();
            initParticleField();
        }
        
        // ============================================
        // SCROLL HANDLING
        // ============================================
        function setupScrollHandling() {
            const sections = document.querySelectorAll('.section');
            const dots = document.querySelectorAll('.indicator-dot');
            
            // Use Intersection Observer for better performance
            const observerOptions = {
                root: null,
                rootMargin: '0px',
                threshold: 0.5
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const sectionIndex = Array.from(sections).indexOf(entry.target);
                        
                        // Update dots
                        dots.forEach((dot, i) => {
                            dot.classList.toggle('active', i === sectionIndex);
                        });
                        
                        // Update current scene
                        const sceneName = entry.target.dataset.scene;
                        currentScene = sceneName;
                        
                        // Close copy panel when scrolling
                        if (copyPanelOpen) {
                            document.getElementById('copyPanel').classList.remove('active');
                            copyPanelOpen = false;
                        }
                    }
                });
            }, observerOptions);
            
            sections.forEach(section => observer.observe(section));
            
            // Dot click navigation
            dots.forEach((dot, i) => {
                dot.addEventListener('click', () => {
                    sections[i].scrollIntoView({ behavior: 'smooth' });
                });
            });
        }
        
        // ============================================
        // COPY PANEL FUNCTIONALITY
        // ============================================
        function setupCopyPanel() {
            const copyPanel = document.getElementById('copyPanel');
            const codePreview = document.getElementById('codePreview');
            const copyBtn = document.getElementById('copyBtn');
            const toast = document.getElementById('toast');
            
            // Click on section to open copy panel
            document.querySelectorAll('.section').forEach(section => {
                section.addEventListener('click', (e) => {
                    // Don't trigger if clicking on controls
                    if (e.target.tagName === 'CANVAS') {
                        const sceneName = section.dataset.scene;
                        currentScene = sceneName;
                        
                        if (sceneCodes[sceneName]) {
                            codePreview.textContent = sceneCodes[sceneName];
                            copyPanel.classList.add('active');
                            copyPanelOpen = true;
                        }
                    }
                });
            });
            
            // Clipboard copy
            const clipboard = new ClipboardJS('#copyBtn');
            
            clipboard.on('success', (e) => {
                copyBtn.textContent = 'Copied!';
                copyBtn.classList.add('copied');
                
                toast.classList.add('show');
                
                setTimeout(() => {
                    copyBtn.textContent = 'Copy to Clipboard';
                    copyBtn.classList.remove('copied');
                    toast.classList.remove('show');
                }, 2000);
                
                e.clearSelection();
            });
            
            // Close panel when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.copy-panel') && !e.target.closest('.section')) {
                    copyPanel.classList.remove('active');
                    copyPanelOpen = false;
                }
            });
        }
        
        // ============================================
        // RESIZE HANDLING
        // ============================================
        function setupResizeHandling() {
            window.addEventListener('resize', () => {
                Object.values(scenes).forEach(({ renderer, camera }) => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            });
        }
        
        // ============================================
        // INITIALIZE
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initAllScenes();
            setupScrollHandling();
            setupCopyPanel();
            setupResizeHandling();
        });
    </script>
</body>
</html>